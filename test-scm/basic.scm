(define counter 0)
(define (assert x)
    (if (eq nil (eval x))
      ((lambda (x) (print counter) (print x)) x)
      (progn
        (print x)
        (set! counter (+ counter 1)))
    )
)
;; basic expressions
(assert 't)
(assert '(not nil))
(assert '(eq nil '()))
(assert '(not '()))
(assert '42)
(assert ''foo)
(assert ''(1 2 3))
;; eq
(assert '(eq t t))
(assert '(eq nil nil))
(assert '(not (eq t nil)))
(assert '(not (eq nil t)))
(assert '(eq t t))
(assert '(eq 42 42))
(assert '(not(eq 42 0)))
(assert '(eq 'foo 'foo))
(assert '(not(eq 'foo 'bar)))
;; symbols
(define foo 'bar)
(assert '(set! foo 'bar))
(assert ''foo)
(assert '(set! foo '(1 2 3)))
(assert ''foo)
;; cons
(assert '(cons 'foo 'bar))
;; first
(assert '(not (first '())))
(assert '(not (car (first '()))))
(assert '(first '(t)))
(assert '(eq 'bar (first '(bar))))
;; rest
(assert '(not (rest '())))
(assert '(eq nil (rest nil)))
(assert '(eq nil (cdr (rest '()))))
;; list
(assert '(eq nil (list)))
(assert '(length (list 'foo 'bar)))
;; length
(assert '(eq (length nil) 0))
(assert '(eq (length nil) (length nil)))
(assert '(not (eq (length '(1)) (length nil))))
;; if
(assert '(if t t))
(assert '(not (if t nil)))
(assert '(if t t nil))
(assert '(if nil nil t))
;; lambda
(assert '(lambda () ()))
(assert '(lambda (x) t))
(assert '((lambda (x) t) 42))
(assert '(eq 42 ((lambda (x) x) 42)))
(define foobar 42)
(assert '(eq 42 ((lambda () foobar))))
;; apply
(assert '(apply first '((t))))
(assert '(not (apply rest '((t)))))
(assert
    '(apply cons '(foo 'bar)))
;; (assert
;;     '(eq 42 (apply funcall '(car (42 0)))
;;     ))
;; funcall
(assert
    '(funcall (lambda () t)))
(assert
    '(funcall (lambda (x y) (cons x y)) 'foo 'bar))
;; math
(assert '(eq 0 (+)))
(assert '(eq 1 (*)))
(assert '(eq 42 (+ 42)))
(assert '(eq -42 (- 42)))
(assert '(eq 42 (* 42)))
(assert '(eq 42 (/ 42)))
(assert '(eq 10 (+ 1 2 3 4)))
(assert '(eq -8 (- 1 2 3 4)))
(assert '(eq 42 (* 21 2)))
(assert '(eq 42 (/ 84 2)))
;; booleans
(assert '(gt 42 -42))
(assert '(gt 0 -1 -2 -3))
(assert '(lt -42 42))
(assert '(lt -1 0 1 2 3))
;; recursion
(define (lt_or_eq x y) (or (< x y) (eq x y)))
(define (fooer x)
  (if (lt_or_eq x 0)
      x
      (fooer (sub x 1)))
)
(assert (eq 0 (fooer 42)))
(assert (eq -42 (fooer -42)))
(define (range x max)
  (if (> x max)
      nil
      (cons x (range (+ x 1) max))
  )
)
(assert '(eq 10 (length (range 0 9))))
(assert '(eq 42 (length (range 0 41))))

(assert '(eq 903 (apply + (range 0 42))))
(define (fib x)
  (if (or (< x 1) (eq x 1))
      x
      (let ((x (sub x 1))
            (y (sub x 2)))
          (+ (fib x) (fib y))
      )
  )
)
(assert '(eq 0 (fib 0)))
(assert '(eq 1 (fib 1)))
(assert '(eq 1 (fib 2)))
(assert '(eq 2 (fib 3)))
(assert '(eq 2 (fib 3)))
(assert '(eq 5 (fib 5)))
(assert '(eq 55 (fib 10)))
;; Delayed evaluation Fibonacci
(define (layz-fib x)
  (if (or (< x 1) (eq x 1))
      (list '+ x 0)
      (list '+ (layz-fib (sub x 1)) (layz-fib (sub x 2)))
  )
)
(assert '(eq 0 (eval (layz-fib 0))))
(assert '(eq 1 (eval (layz-fib 1))))
(assert '(eq 1 (eval (layz-fib 2))))
(assert '(eq 2 (eval (layz-fib 3))))
(assert '(eq 2 (eval (layz-fib 3))))
(assert '(eq 5 (eval (layz-fib 5))))
(assert '(eq 55 (eval (layz-fib 10))))
(define result 6765)
(assert '(eq result (eval (layz-fib 20))))
(set! result 832040)
(assert '(eq result (eval (layz-fib 30)))) ;; 32 is the max as of 5-17-25
(print 'END)
(assert nil)